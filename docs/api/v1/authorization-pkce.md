---
id: authorization-pkce
title: PKCE (Proof Key for Code Exchange)
keywords:
    - authentication
    - Oauth2
    - authorization_code
    - refresh_token
    - client_credentials
    - access_token
    - openid
modified: 2022-02-05 19:27
---

# Introducing

Proof Key for Code Exchange (abbreviated PKCE, pronounced “pixie”) is an extension to the authorization code flow to prevent CSRF and authorization code injection attacks.

PKCE provides dynamic client secrets, meaning your app’s client secrets can stay secret (even without a back end for your app). PKCE is better and more secure than the implicit flow (AKA the “token flow”). Therefore, Portalnesia does not implement implicit authentication flow.

In this post, we’ll look at how PKCE works, why it’s important, and how you can start using PKCE flows in your Portalnesia apps today.


# PKCE Builds on OAuth 2.0

PKCE is a new, more secure authorization flow (based on the OAuth 2.0 spec) that was originally created to better secure mobile apps. From the [official OAuth 2.0 spec](https://oauth.net/2/pkce/) for PKCE:

> PKCE ([RFC 7636](https://tools.ietf.org/html/rfc7636)) is an extension to the [Authorization Code flow](/developer/docs/authorization-code-flow) to prevent several attacks and to be able to securely perform the OAuth exchange from public clients.

The OAuth 2.0 spec is the industry standard protocol for authorization and allows users to grant permission for apps to access their Portalnesia data. Using OAuth 2.0, users can access their Portalnesia data from third party applications without sensitive information (like passwords) ever changing hands.

In basic `authorization_code` flow, that process relies on apps providing a `client_secret` in the final request for an access token. For certain types of apps, that makes leaking the secret an inherent, unavoidable risk, which is why they instead needed to rely on an implicit flow.

Because these are public clients, there’s no way for them to guarantee the security of the secret used for the token exchange. Using the implicit flow solves for that, but with the added risk of exposing the access token in the redirect URI at the end of the authorization flow, which makes the flow vulnerable to different types of network and malicious app interceptions.

By using PKCE, public clients can take advantage of the authorization code flow, which works by substituting the static client secret with a string that is dynamically generated. By doing so, the PKCE flow eliminates leaky secrets while allowing the authorization server to verify that the app requesting the access token is the same one that initiated the OAuth flow.


# PKCE Implementation

Building on top of the authorization code flow, there are three new parameters used by PKCE: `code_verifier`, `code_challenge`, and `code_challenge_method`. But, Portalnesia only implements `code_verifier` and `code_challenge` parameters. Let’s define them before adding more context around the overall flow.


## Code Verifier 

The `code_verifier` is a cryptographically random string generated by your app. This dynamically created string is used to correlate the final access token request with the initial authorization request. In other words, the `code_verifier` is how the Portalnesia authorization server ensures that the access token is issued to the same app that requested authorization.

## Code Challenge

The `code_challenge` is derived from the `code_verifier` using one of the two possible transformations: plain and S256. Plain can only be used when S256 is not possible. For the majority of use cases, the `code_challenge` will be a base 64 encoding of an SHA256 hash made with the client_verifier. This string gets decrypted server-side and is used to verify that the requests are coming from the same client.

## Code Challenge Method

The `code_challenge_method` tells the server which function was used to transform the `code_verifier` (plain or S256). Portalnesia OAuth2 service does not implement `code_challenge_method`, and the method used is always `S256`

These new parameters are used to supplement the authorization code flow to create a powerful system of checks that allow the server to verify that the authorization request and token request both come from the same client.

When a user kicks off a PKCE authorization flow in your app, here’s what takes place:

1. Client (your app) creates the `code_verifier`. ([RFC 7636, Section 4.1](https://tools.ietf.org/html/rfc7636#section-4.1))
1. Client creates the `code_challenge` by transforming the `code_verifier` using S256 encryption. ([RFC 7636, Section 4.2](https://tools.ietf.org/html/rfc7636#section-4.2))
1. Client sends the `code_challenge` with the initial authorization request. ([RFC 7636, Section 4.3](https://tools.ietf.org/html/rfc7636#section-4.3))
1. Portalnesia OAuth2 service responds with an `authorization_code`. ([RFC 7636, Section 4.4](https://tools.ietf.org/html/rfc7636#section-4.4))
1. Client sends `authorization_code` and `code_verifier` to the token endpoint. ([RFC 7636, Section 4.5](https://tools.ietf.org/html/rfc7636#section-4.5))
1. Portalnesia OAuth2 service transforms the `code_verifier` using the S256 encryption from the initial authorization request and checks the result against the `code_challenge`. If the value of both strings match, then the server has verified that the requests came from the same client and will issue an access_token. ([RFC 7636, Section 4.6](https://tools.ietf.org/html/rfc7636#section-4.6))


Now that we understand the flow, let’s see what it looks like in practice.

# Testing the PKCE Flow

In these samples, we’re using Node.js to generate the dynamic strings and curl to send our requests to the Portalnesia API. In production, the string generation and API requests would happen in the same app. You’ll need a Portalnesia app to follow along.

Start by creating a new JavaScript file and importing the crypto module (already bundled with Node), which we’ll use for the SHA-256 encryption:

### Creates code_verifier and code_challenge

Client creates `code_verifier` and subsequent `code_challenge`

Add the following snippet to your JavaScript file

```js
const crypto = require("crypto")

const base64UrlEncode = (str) => {
    return str.toString('base64')
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
}
const codeVerifier = base64Encode(crypto.randomBytes(128));
console.log(`Client generated code_verifier: ${codeVerifier}`)

const sha256 = (buffer) => {
    return crypto.createHash('sha256').update(buffer).digest();
}
const codeChallenge = base64UrlEncode(sha256(codeVerifier));
console.log(`Client generated code_challenge: ${codeChallenge}`)
```

Run the script with:

```bash
node <your_filename>
```

The console will output the generated strings:

```plaintext
Client generated code_verifier:  kiNgBo0...oxtXtFce4
Client generated code_challenge: lSEB3zK...y5a7dQyk
```

### Sends code_challenge

Client sends `code_challenge` to [/oauth/authorization](https://accounts.portalnesia.com/oauth/authorization).

Manually assemble the authorization URL and replace the variables with your own information

```plaintext
https://accounts.portalnesia.com/oauth/authorization?client_id=<Your_Client_Id>&response_type=code&code_challenge=<CHALLENGE>...
```

Navigate to the authorization URL and click 'Allow'


### Get Authorization Code

Portalnesia OAuth2 Service responds with authorization code

Copy the `code` sent to your app `redirect_uri`

### Sends authorization_code and code_verifier

Client sends `authorization_code` and `code_verifier` to [/oauth/token](https://accounts.portalnesia.com/oauth/token)

Manually assemble the CURL request and replace the variables with your information

```bash
curl https://accounts.portalnesia.com/oauth/token \
 -header 'PN-Client-Id: <Your_Client_Id>' \
 -header 'Content-type: application/x-www-form-urlencoded' \
 -d code=<AUTHORIZATION_CODE> \
 -d grant_type=authorization_code \
 -d code_verifier=<CODE_VERIFIER> \
 -d client_id=<Your_Client_Id>
 -d redirect_uri=<REDIRECT_URI>
```

Portalnesia OAuth2 Service encrypts and compares `code_verifier` with `code_challenge` to verify source of authorization and token requests match.

Portalnesia OAuth2 Service issues an access token:

```json
{
  "id_token": "eyJhbGcI6IkpXVCJ9...Ok6yJV_adQssw5c",
  "access_token": "NgCXRK...MzYjw",
  "token_type": "Bearer",
  "scope": "basic blog chord",
  "expires_in": 3600,
  "refresh_token": "NgAagA...Um_SHo"
}
```

### PKCE Implementation Success

Do a victory dance. You made it!

Optionally, you can test your new access token.

```bash
curl -X POST https://api.portalnesia.com/v1/user \
 --header "Authorization: Bearer <Your_Access_Token>" \
 --header "PN-Client-Id: <Your_Client_Id>"
```