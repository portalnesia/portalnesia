---
id: authorization-code-flow
title: Authorization Code
keywords:
    - authentication
    - Oauth2
    - authorization_code
    - refresh_token
    - client_credentials
    - access_token
    - openid
modified: 2022-02-05 19:27
---

The authorization code flow is suitable for long-running applications (e.g. web and mobile apps) where the user grants permission only once.

If you’re using the authorization code flow in a mobile app, or any other type of application where the client secret can’t be safely stored, then you should use the PKCE extension. Keep reading to learn how to correctly implement it.

# Prerequisites

This guide assumes that you have created an app following the [app settings docs](/developer/docs/app-settings).


# Request User Authorization

The first step is to request authorization from the user, so our app can access to the Portalnesia resources in behalf that user. To do so, our application must build and send a GET request to the `https://accounts.portalnesia.com/oauth/authorization` endpoint with the following parameters:

| QUERY PARAMETER | VALUE |
| --- | --- |
| client_id | *Required*<br />The Client ID generated after registering your application. |
| response_type | *Required*<br />Set to `code` |
| redirect_uri | *Required*<br />The URI to redirect to after the user grants or denies permission. This URI needs to have been entered in the `Callback URI` allowlist that you specified when you registered your application (See the app settings docs). The value of redirect_uri here must exactly match one of the values you entered when you registered your application, including upper or lowercase, terminating slashes, and such. |
| state | *Optional, but strongly recommended*<br />This provides protection against attacks such as cross-site request forgery. See [RFC-6749](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1). |
| scope | *Optional*<br />A space-separated list of scopes. If no scopes are specified, authorization will be granted only with default `basic` scope. |
| show_dialog | *Optional*<br />Whether or not to force the user to approve the app again if they’ve already done so. If `false` (default), a user who has already approved the application may be automatically redirected to the URI specified by `redirect_uri`. If `true`, the user will not be automatically redirected and will have to approve the app again. |

> `show dialog` **will always be true** if your application requests user authorization using a different scope than before

If you are implementing the PKCE extension, you must include these additional parameters:

| QUERY PARAMETER | VALUE |
| --- | --- |
| code_challenge | *Required*<br />Set to code_challenge generated by your app. |

> In order to generate the `code_challenge`, your app should hash the code verifier using the SHA256 algorithm. The code verifier is a random string between 43 and 128 characters in length. It can contain letters, digits, underscores, periods, hyphens, or tildes.

Example generate the `code_challenge` with nodejs, or you can use any of pkce challenge library from npm:

```js
const randomstring = require("randomstring");
const crypto = require("crypto");

/**
 * Generate code verifier, random string between 43 and 128 characters
 */
const code_verifier = randomstring.generate(128);

function base64UrlEncode(base64) {
  return base64
    .replace(/=/g, "")
    .replace(/\+/g, "-")
    .replace(/\//g, "_");
}

function generateChallenge(code_verifier) {
  const hash = createHash("sha256")
    .update(code_verifier)
    .digest("base64");
  return base64UrlEncode(hash);
}

const code_challenge = generateChallenge(code_verifier)
```

The Portalnesia OAuth 2.0 service presents details of the scopes for which access is being sought. If the user is not logged in, they are prompted to do so using their Portalnesia credentials. When the user is logged in, they are asked to authorize access to the data sets or features defined in the scopes.

Finally, the user is redirected back to your specified redirect_uri. After the user accepts, or denies your request, the Portalnesia OAuth 2.0 service redirects the user back to your `redirect_uri`

# Authorization Response

If the user accepts your request, then the user is redirected back to the application using the `redirect_uri` passed on the authorized request described above.

| QUERY PARAMETER | VALUE |
| --- | --- |
| code | An authorization code that can be exchanged for an Access Token. |
| state | The value of the state parameter supplied in the request. |

Example, if your `redirect_uri` is `https://domain/callback`:

```
https://domain/callback?code=NApCCgagq..BkWtQ&state=34fFs29kd09
```

If the user does not accept your request or if an error has occurred, the response query string contains the following parameters:

| QUERY PARAMETER | VALUE |
| --- | --- |
| error | The reason authorization failed, for example: “access_denied” |
| state | The value of the state parameter supplied in the request. |

Example, if your `redirect_uri` is `https://domain/callback`:

```
https://domain/callback?error=access_denied&state=34fFs29kd09
```

# Request Access Token

If the user accepted your request, then your app is ready to exchange the authorization code for an Access Token. It can do this by making a POST request to the `https://accouts.portalnesia.com/oauth/token` endpoint.

The body of this POST request must contain the following parameters encoded in application/x-www-form-urlencoded:

| REQUEST BODY PARAMETER | VALUE |
| --- | --- |
| grant_type | *Required*<br />This field must contain the value `authorization_code`.  |
| code | *Required*<br />The authorization code returned from the previous request. |
| redirect_uri | *Required*<br />This parameter is used for validation only (there is no actual redirection). The value of this parameter must exactly match the value of `redirect_uri` supplied when requesting the authorization code. |

If you are implementing the PKCE extension, these additional parameters must be included as well:

| REQUEST BODY PARAMETER | VALUE |
| --- | --- |
| code_verifier | *Required*<br />The value of this parameter must match the value of the `code_verifier` that your app generated in the previous step. |

The request must include the following HTTP headers:

| HEADER PARAMETER | VALUE |
| --- | --- |
| PN-Client-Id | *Required*<br />The client ID for your app, available from the developer dashboard. |
| Authorization | *Required if not implementing PKCE*<br />Base 64 encoded string that contains the client ID and client secret key. The field must have the format: `Authorization: Basic <base64 encoded client_id:client_secret>` |
| Content-Type | *Required*<br />Set to `application/x-www-form-urlencoded`. |

# Access Token Response

On success, the response will have a 200 OK status and the following JSON data in the response body:

| KEY | TYPE | VALUE |
| --- | --- | --- |
| access_token | *string* | An Access Token that can be provided in subsequent calls |
| token_type | *string* | How the Access Token may be used: always “Bearer”. |
| scope | *string* | A space-separated list of scopes which have been granted for this `access_token` |
| expires_in | *int* | 	The time period (in seconds) for which the Access Token is valid. |
| refresh_token | *string* | A token that can be sent to the Portalnesia Oauth2 service in place of an authorization code. For details, see [Refresh tokens](#request-refreshed-access-token) |
| id_token | *string* | A `JWT` that contains identity information about the user that is digitally signed by Portalnesia. See Obtain user information from the ID token |

The following example, shows how the successful response looks like:

```json
{
  "id_token": "eyJhbGcI6IkpXVCJ9...Ok6yJV_adQssw5c",
  "access_token": "NgCXRK...MzYjw",
  "token_type": "Bearer",
  "scope": "basic blog chord",
  "expires_in": 3600,
  "refresh_token": "NgAagA...Um_SHo"
}
```

# Request Refreshed Access Token

Access tokens are deliberately set to expire after a short time, after which new tokens may be granted by supplying the refresh token originally obtained during the authorization code exchange.

In order to refresh the token, a `POST` request must be sent with the following body parameters encoded in `application/x-www-form-urlencoded`:

| REQUEST BODY PARAMETER | VALUE |
| --- | --- |
| grant_type | *Required*<br />Required Set it to `refresh_token`. |
| refresh_token | *Required*<br />The refresh token returned from the authorization code exchange |

The headers of this POST request must contain the same parameters with [Request Access Token](#request-access-token).

The response will be similar with [Access Token Response](#access-token-response).

